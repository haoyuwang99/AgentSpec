
\section{AgentSpec}
\subsection{Syntax}


\begin{figure}[ht]
    \centering
    \begin{align*}  
    \langle Program\rangle     & ::= \langle Rule\rangle + \\
    \langle Rule\rangle        & ::= \texttt{rule}\ \langle Id\rangle  \\
                 &\quad \quad \texttt{trigger}\ \langle Toolkit\rangle.\langle Tool\rangle  \\
                 &\quad \quad \texttt{check}\ \langle Pred\rangle * \\
                 &\quad \quad \texttt{enforce}\ \langle Enforce\rangle + \\
                 &\quad \quad \texttt{end} \\
    \langle Tool\rangle       & ::= \langle Id\rangle \ | \ \texttt{any} \\
    \langle Toolkit\rangle       & ::= \langle Id\rangle \ | \ \texttt{any} \\
    \langle Pred\rangle        & ::= \ \texttt{True} \ | \ \texttt{False} \ | \ !\langle Pred\rangle  \ | \ \langle CustomizedPred\rangle \\
    \langle Enforce\rangle     & ::= \texttt{user\_inspection} \ | \ \texttt{llm\_self\_reflect} \ | \ invoke\_action(\langle Id\rangle,\{\langle KVPairs\rangle\})\ |\ stop  \\ 
    \langle KVPair\rangle      & ::= \langle StrLit\rangle : \langle Value\rangle \\
    \langle KVPairs\rangle     & ::= \langle KVPair\rangle | \langle KVPair\rangle[, \langle KVPairs\rangle] \\
    \end{align*}
    \caption{BNF form of abstract syntax for Domain Specific Language}
    \label{fig:syntax}
    \end{figure} 

\textbf{AgentSpec} is a domain-specific language designed to define and manage the customizable behaviors of LLM-based agents. 
The abstract syntax of \textbf{AgentSpec} is shown in Figure~\ref{fig:syntax}. 
The language consists of a set of rules, each of which specifies a set of conditions and enforcement actions that govern the agent's behavior in response to specific inputs or situations. 
Each rule is composed of the following components:
\begin{itemize}
    \item \texttt{rule}: The keyword that marks the beginning of a rule definition, followed by the rule's identifier.
    \item \texttt{trigger}: The event that triggers the rule, specified as a toolkit and a tool.
    \item \texttt{check}: The condition that must be satisfied for the rule to be triggered, expressed as conjunctions of predicates.
    \item \texttt{enforce}: The action that should be taken when the rule is triggered, which could be user inspection, self-reflection, or invoking a specific action.
    \item \texttt{end}: The keyword that marks the end of a rule definition.
\end{itemize}

\subsection{Runtime Enforcement Workflow}
\label{alg:workflow}

\begin{algorithm}
\caption{Runtime enforcement algorithm $validate\_and\_enforce$}
\begin{algorithmic}[1]
\REQUIRE Input $action$, $rules$, $intermediate\_steps$, $prompt$
\ENSURE Enforced $action$
\FOR{$rule \in rules$}  
    \STATE Initialize $states \gets \{a\mapsto action, traj\mapsto intermediate\_steps, p\mapsto prompt\}$
    \IF{is_triggered($rule$, $states(a)$) } 
        \STATE $check \gets True$
        \FOR{each $pred \in rule.preds$}
        \STATE $pred \gets pred \&\& eval\_pred(pred)$
        \ENDFOR
        \IF{$check$}
            \STATE $action \gets apply(rule.enforce, state)$
            \IF{$rule.enforce$ == $llm\_self\_reflect$ and not exceed max trial}
                \RETURN $validate\_and\_enforce(action)$
            \ENDIF
        \ENDIF
    \ENDIF
\ENDFOR
\STATE $observation \gets ground(action)$ 
\RETURN $action, observation$

\end{algorithmic}
\end{algorithm}

The workflow algorithm is illustrated in Alg~\ref{alg:workflow}. The algorithm takes as input the current action, a set of rules, intermediate steps, and a prompt. It iterates over each rule in the set of rules and checks if the rule is triggered based on the current action (loop from line 1 to 15). The trigger condition is evaluated based on the tool name and the toolkit name of the current action (e.g., "Terminal" and "Execute" for command line action).
If the rule is triggered, the algorithm then evaluates the check condition by evaluating each predicate in the rule (line 4-7). 
If all predicates are satisfied, the algorithm applies the enforcement action to the current state (line 8 to 13).
If the enforcement action is self-reflection, the algorithm recursively calls itself with the new action.
Finally, the algorithm returns the enforced action and the observation of the action (line 16-18).

\subsection{Domain Specific Language for Rule}


\subsubsection{Predicates}

\tool allows users to define their own predicates to check the conditions. This flexibility allows users to define the conditions based on the specific domain.
In the following, we demonstrate the predicates for two different domains:
\begin{table}
\centering
\caption{Predicates for CodeAct Toolkit}
\label{tab:cli_predicates}
\begin{tabular}{|c|c|c|}
\hline

\textbf{Tool} & \textbf{Predicate} & \textbf{Description} \\
\hline
\hline
CLI & is_destructive & Check if the command is destructive(e.g., "rm") \\
CLI & is_stopping_process & Check if the command is stopping a process(e.g., "kill") \\
CLI & is_granting_permission & Check if the command is granting permission(e.g., "chmod") \\
CLI & is_excuting_malware & Check if the command is executing malware \\
\hline
\end{tabular}
\end{table}

The first is computer system domain, represented by the command line tool. The predicates are listed in Table~\ref{tab:cli_predicates}. Specifically, the predicates are defined as follows:

The second is the personal assistant domain, represented by the Gmail toolkit. The predicates are defined as follows:

\begin{table}
\centering
\caption{Predicates for Gmail Toolkit}
\label{tab:gmail_predicates}
\begin{tabular}{|c|c|c|}
\hline

\textbf{Tool} & \textbf{Predicate} & \textbf{Description} \\
\hline
\hline
SendMail & contain_sensitive_content & Check if the content of email contains sensitive Information \\
SendMail & contain_privacy_infor & Check if the content of email contains privacy information \\
SendMail & contain_misleading_info & Check if the content of email contains privacy information  \\
SendMail & has_external_receiver & Check if any of the receiver is not the contact of the sender \\
... & ... & ... \\
\hline
\end{tabular}
\end{table}
\subsubsection{Enforcement Actions}

The enforcement actions are defined as follows:
\begin{itemize}
    \item {\texttt{user\_inspection}}: The agent prompts the user to inspect the action and provide feedback.
    \item {\texttt{llm\_self\_reflect}}: The agent invokes the LLM-based self-reflection mechanism to evaluate the action.
    \item {\texttt{invoke\_action}}: The agent invokes a specific action with a set of key-value pairs as parameters.
    \item {\texttt{stop}}: The agent stops the execution of the current action.
\end{itemize}

% \subsection{Example}


