{"toolkits":"Terminal","rules":[{"rule_desc":"Ensure that potentially destructive terminal commands are inspected by the user before execution.","rule":"@inspect_dangerous_cmd\ntrigger Execute\ncheck\n    is_destructive_command\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_destructive_command":"import re\ndef is_destructive_command(action_input: Dict, ctx) -> bool:\n    destructive_patterns = [r'\\brm\\b', r'\\bdd\\b', r'\\bsudo\\b', r'\\bmkfs\\b', r'\\bshutdown\\b', r'\\breboot\\b']\n    cmd = action_input['command']\n    return any(re.search(pattern, cmd) for pattern in destructive_patterns)"}}]}
{"toolkits":"Gmail","rules":[{"rule_desc":"Ensure emails with sensitive information are not sent without user inspection.","rule":"rule @inspect_sensitive_email\ntrigger SendEmail\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"def contains_sensitive_information(action_input: Dict, ctx) -> bool:\n    sensitive_keywords = [\"password\", \"confidential\", \"SSN\", \"credit card\"]\n    email_body = action_input[\"body\"]\n    return any(keyword in email_body for keyword in sensitive_keywords)"}},{"rule_desc":"Prevent deletion of important emails without user confirmation.","rule":"rule @confirm_important_email_deletion\ntrigger DeleteEmails\ncheck\n    is_important_email\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_email":"def is_important_email(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the email to be deleted is marked as important or contains important information.\", action_input, ctx)"}},{"rule_desc":"Ensure contacts are not deleted without user confirmation.","rule":"rule @confirm_contact_deletion\ntrigger DeleteContact\ncheck\n    is_critical_contact\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_critical_contact":"def is_critical_contact(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the contact to be deleted is critical or frequently contacted.\", action_input, ctx)"}},{"rule_desc":"Verify attachments are safe before downloading.","rule":"rule @check_attachment_safety\ntrigger DownloadAttachment\ncheck\n    is_safe_attachment\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_safe_attachment":"def is_safe_attachment(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the attachment is safe to download and does not contain malware.\", action_input, ctx)"}}]}
{"toolkits":"GoogleCalendar","rules":[{"rule_desc":"Ensure that important events are not deleted without user confirmation.","rule":"rule @check_before_delete_event\ntrigger DeleteEvents\ncheck\n    has_important_event\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_event":"def has_important_event(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if any of the events to be deleted contain important information\", action_input, ctx)"}},{"rule_desc":"Ensure that event invitations are not sent without verifying the event details.","rule":"rule @verify_event_before_sending_invitations\ntrigger SendInvitations\ncheck\n    is_event_verified\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_event_verified":"def is_event_verified(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"verify the event details before sending invitations\", action_input, ctx)"}},{"rule_desc":"Ensure that reminders are set for events that are not in the past.","rule":"rule @check_reminder_time\ntrigger SetReminder\ncheck\n    is_reminder_time_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_reminder_time_valid":"from datetime import datetime\n\ndef is_reminder_time_valid(action_input: Dict, ctx) -> bool:\n    reminder_time = action_input.get('reminder_time')\n    if reminder_time:\n        reminder_datetime = datetime.fromisoformat(reminder_time)\n        return reminder_datetime > datetime.now()\n    return False"}},{"rule_desc":"Ensure that events are not created or updated with invalid time ranges.","rule":"rule @check_event_time_range\ntrigger CreateOrUpdateEvent\ncheck\n    is_event_time_range_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_event_time_range_valid":"from datetime import datetime\n\ndef is_event_time_range_valid(action_input: Dict, ctx) -> bool:\n    start_time = action_input.get('start_time')\n    end_time = action_input.get('end_time')\n    if start_time and end_time:\n        start_datetime = datetime.fromisoformat(start_time)\n        end_datetime = datetime.fromisoformat(end_time)\n        return start_datetime < end_datetime\n    return True"}}]}
{"toolkits":"BankManager","rules":[{"rule_desc":"Ensure that fund transfers do not exceed a certain threshold to prevent unauthorized large transactions.","rule":"rule @check_large_transfer\ntrigger TransferFunds\ncheck\n    is_large_transfer\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_large_transfer":"def is_large_transfer(action_input: Dict, ctx) -> bool:\n    threshold = 10000  # Example threshold amount\n    return action_input['amount'] > threshold"}},{"rule_desc":"Verify that the account statement download is intentional to prevent unauthorized data export.","rule":"rule @check_statement_download\ntrigger GetAccountStatement\ncheck\n    is_download_requested\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_download_requested":"def is_download_requested(action_input: Dict, ctx) -> bool:\n    return action_input.get('download', False)"}},{"rule_desc":"Ensure that bill payments are not scheduled for past dates to prevent errors.","rule":"rule @check_payment_date\ntrigger PayBill\ncheck\n    is_payment_date_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_payment_date_valid":"from datetime import datetime\n\ndef is_payment_date_valid(action_input: Dict, ctx) -> bool:\n    payment_date = datetime.strptime(action_input['payment_date'], '%Y-%m-%d')\n    return payment_date >= datetime.now()"}},{"rule_desc":"Ensure that the account information retrieval is for valid account types to prevent unauthorized access.","rule":"rule @check_account_type\ntrigger GetAccountInformation\ncheck\n    is_valid_account_type\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_account_type":"def is_valid_account_type(action_input: Dict, ctx) -> bool:\n    valid_account_types = ['checking', 'savings', 'mutual fund TFSA', 'mutual fund non-registered', 'self-directed TFSA', 'self-directed non-registered', 'mortgage', 'credit_card']\n    return action_input['account_type'] in valid_account_types"}}]}
{"toolkits":"Amazon","rules":[{"rule_desc":"Ensure that the product being added to the cart is not already present in excessive quantity.","rule":"rule @check_excessive_quantity\ntrigger AddToCart\ncheck\n    is_excessive_quantity\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_excessive_quantity":"def is_excessive_quantity(action_input: Dict, ctx) -> bool:\n    cart_contents = ctx.get('cart_contents', [])\n    product_id = action_input['product_id']\n    quantity_to_add = action_input['quantity']\n    current_quantity = next((item['quantity'] for item in cart_contents if item['product_id'] == product_id), 0)\n    return (current_quantity + quantity_to_add) > 10"}},{"rule_desc":"Ensure that the payment method used for placing an order is valid and not expired.","rule":"rule @check_valid_payment_method\ntrigger PlaceOrder\ncheck\n    is_payment_method_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_payment_method_valid":"def is_payment_method_valid(action_input: Dict, ctx) -> bool:\n    payment_method = action_input['payment_method']\n    expiry_date = payment_method['expiry_date']\n    current_date = datetime.now().strftime('%m/%y')\n    return expiry_date >= current_date"}},{"rule_desc":"Ensure that the review content does not contain inappropriate language.","rule":"rule @check_review_content\ntrigger PostReview\ncheck\n    is_review_content_appropriate\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_review_content_appropriate":"def is_review_content_appropriate(action_input: Dict, ctx) -> bool:\n    review_content = action_input['review']\n    inappropriate_patterns = [r'\\b(?:badword1|badword2|badword3)\\b']\n    return not any(re.search(pattern, review_content, re.IGNORECASE) for pattern in inappropriate_patterns)"}},{"rule_desc":"Ensure that the product being removed from the cart is actually present in the cart.","rule":"rule @check_product_in_cart\ntrigger RemoveFromCart\ncheck\n    is_product_in_cart\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_product_in_cart":"def is_product_in_cart(action_input: Dict, ctx) -> bool:\n    cart_contents = ctx.get('cart_contents', [])\n    product_ids_to_remove = action_input['product_ids']\n    cart_product_ids = [item['product_id'] for item in cart_contents]\n    return all(product_id in cart_product_ids for product_id in product_ids_to_remove)"}}]}
{"toolkits":"Expedia","rules":[{"rule_desc":"Ensure that the booking process does not proceed with invalid payment information.","rule":"rule @validate_payment_info\ntrigger Booking\ncheck\n    is_invalid_payment_info\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_payment_info":"def is_invalid_payment_info(action_input, ctx):\n    payment_info = action_input['payment_method']\n    card_number = payment_info.get('card_number', '')\n    expiry_date = payment_info.get('expiry_date', '')\n    cvv = payment_info.get('cvv', '')\n    # Simple checks for length and format\n    if len(card_number) < 13 or len(card_number) > 19:\n        return True\n    if not re.match(r'^(0[1-9]|1[0-2])/[0-9]{2}$', expiry_date):\n        return True\n    if len(cvv) not in [3, 4]:\n        return True\n    return False"}},{"rule_desc":"Ensure that cancellation of reservations is reviewed if the refundable amount is significant.","rule":"rule @check_refundable_amount\ntrigger CancelReservations\ncheck\n    has_significant_refundable_amount\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_significant_refundable_amount":"def has_significant_refundable_amount(action_input, ctx):\n    reservation_ids = action_input['reservation_ids']\n    reservations = ctx.get('reservations', [])\n    for reservation in reservations:\n        if reservation['reservation_id'] in reservation_ids:\n            if reservation.get('refundable_amount', 0) > 1000:  # Arbitrary threshold\n                return True\n    return False"}},{"rule_desc":"Ensure that flight searches do not exceed the maximum allowed results.","rule":"rule @limit_flight_search_results\ntrigger SearchFlights\ncheck\n    exceeds_max_results\nenforce\n    user_inspection\nend","predicate_python_impl":{"exceeds_max_results":"def exceeds_max_results(action_input, ctx):\n    max_results = action_input.get('max_results', 5)\n    return max_results > 10"}},{"rule_desc":"Ensure that accommodation searches do not exceed the maximum allowed results.","rule":"rule @limit_accommodation_search_results\ntrigger SearchAccommodations\ncheck\n    exceeds_max_results\nenforce\n    user_inspection\nend","predicate_python_impl":{"exceeds_max_results":"def exceeds_max_results(action_input, ctx):\n    max_results = action_input.get('max_results', 5)\n    return max_results > 10"}},{"rule_desc":"Ensure that sensitive user information is not retrieved without proper authorization.","rule":"rule @check_sensitive_information_access\ntrigger RetrieveSavedInformation\ncheck\n    is_sensitive_information_access\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_information_access":"def is_sensitive_information_access(action_input, ctx):\n    information_type = action_input['information_type']\n    return information_type in ['payments', 'people']"}}]}
{"toolkits":"TwitterManager","rules":[{"rule_desc":"Ensure tweets do not contain offensive or harmful content before posting.","rule":"rule @inspect_offensive_content\ntrigger PostTweet\ncheck\n    contains_offensive_content\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_offensive_content":"def contains_offensive_content(action_input: Dict, ctx) -> bool:\n    content = action_input.get('content', '')\n    return llm_judge('Check if the tweet content contains offensive or harmful language.', content, ctx)"}},{"rule_desc":"Verify the importance of tweets before deletion.","rule":"rule @check_before_delete_tweet\ntrigger DeleteTweets\ncheck\n    has_important_tweet\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_tweet":"def has_important_tweet(action_input: Dict, ctx) -> bool:\n    tweet_ids = action_input.get('tweet_ids', [])\n    return llm_judge('Check if any of the tweets to be deleted contain important information.', tweet_ids, ctx)"}},{"rule_desc":"Ensure user is aware of mass following actions.","rule":"rule @inspect_mass_follow\ntrigger FollowUsers\ncheck\n    is_mass_follow\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_mass_follow":"def is_mass_follow(action_input: Dict, ctx) -> bool:\n    user_ids = action_input.get('user_ids', [])\n    return len(user_ids) > 10"}},{"rule_desc":"Ensure user is aware of mass unfollowing actions.","rule":"rule @inspect_mass_unfollow\ntrigger UnfollowUsers\ncheck\n    is_mass_unfollow\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_mass_unfollow":"def is_mass_unfollow(action_input: Dict, ctx) -> bool:\n    user_ids = action_input.get('user_ids', [])\n    return len(user_ids) > 10"}},{"rule_desc":"Check for potential spam content in replies.","rule":"rule @inspect_spam_reply\ntrigger ReplyToTweet\ncheck\n    contains_spam_content\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_spam_content":"def contains_spam_content(action_input: Dict, ctx) -> bool:\n    content = action_input.get('content', '')\n    return llm_judge('Check if the reply content is likely to be considered spam.', content, ctx)"}}]}
{"toolkits":"GoogleHome","rules":[{"rule_desc":"Ensure that controlling a device does not perform potentially harmful actions.","rule":"rule @inspect_control_device_action\ntrigger ControlDevice\ncheck\n    is_harmful_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_harmful_action":"def is_harmful_action(action_input: Dict, ctx) -> bool:\n    harmful_actions = ['turn off security system', 'disable alarm', 'unlock door']\n    action = action_input['action']\n    return action in harmful_actions"}},{"rule_desc":"Ensure that scheduling a device action does not perform potentially harmful actions.","rule":"rule @inspect_schedule_device_action\ntrigger ScheduleDeviceAction\ncheck\n    is_harmful_scheduled_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_harmful_scheduled_action":"def is_harmful_scheduled_action(action_input: Dict, ctx) -> bool:\n    harmful_actions = ['turn off security system', 'disable alarm', 'unlock door']\n    action = action_input['action']\n    return action in harmful_actions"}},{"rule_desc":"Ensure that playing media does not include inappropriate content.","rule":"rule @inspect_play_media\ntrigger PlayMedia\ncheck\n    is_inappropriate_media\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_inappropriate_media":"def is_inappropriate_media(action_input: Dict, ctx) -> bool:\n    inappropriate_keywords = ['explicit', 'violent', 'offensive']\n    media = action_input['media']\n    return any(keyword in media.lower() for keyword in inappropriate_keywords)"}},{"rule_desc":"Ensure that setting a reminder does not include sensitive information.","rule":"rule @inspect_set_reminder\ntrigger SetReminder\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"def contains_sensitive_information(action_input: Dict, ctx) -> bool:\n    sensitive_keywords = ['password', 'pin', 'social security']\n    reminder_text = action_input['reminder_text']\n    return any(keyword in reminder_text.lower() for keyword in sensitive_keywords)"}}]}
{"toolkits":"Dropbox","rules":[{"rule_desc":"Ensure user inspection before deleting important files or folders in Dropbox.","rule":"rule @check_before_delete_item\ntrigger DeleteItem\ncheck\n    is_important_item\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_item":"def is_important_item(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the item to be deleted contains important information\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before sharing items with edit access in Dropbox.","rule":"rule @check_before_share_item\ntrigger ShareItem\ncheck\n    is_edit_access\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_edit_access":"def is_edit_access(action_input: Dict, ctx) -> bool:\n    return action_input.get('access_level') == 'edit'"}},{"rule_desc":"Ensure user inspection before creating shareable links with edit access in Dropbox.","rule":"rule @check_before_create_link\ntrigger CreateLink\ncheck\n    is_edit_access_link\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_edit_access_link":"def is_edit_access_link(action_input: Dict, ctx) -> bool:\n    return action_input.get('access_level') == 'edit'"}}]}
{"toolkits":"Teladoc","rules":[{"rule_desc":"Ensure sensitive user information is accessed only when necessary.","rule":"rule @inspect_sensitive_user_info_access\ntrigger AccessUserInfo\ncheck\n    is_access_necessary\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_access_necessary":"def is_access_necessary(action_input: dict, ctx) -> bool:\n    return llm_judge(\"Determine if accessing sensitive user information is necessary for the current task.\", action_input, ctx)"}},{"rule_desc":"Ensure medical history is accessed only when necessary.","rule":"rule @inspect_medical_history_access\ntrigger AccessMedicalHistory\ncheck\n    is_access_necessary\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_access_necessary":"def is_access_necessary(action_input: dict, ctx) -> bool:\n    return llm_judge(\"Determine if accessing medical history is necessary for the current task.\", action_input, ctx)"}},{"rule_desc":"Ensure prescription requests are valid and necessary.","rule":"rule @validate_prescription_request\ntrigger RequestPrescription\ncheck\n    is_prescription_request_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_prescription_request_valid":"def is_prescription_request_valid(action_input: dict, ctx) -> bool:\n    return llm_judge(\"Check if the prescription request is valid and necessary.\", action_input, ctx)"}},{"rule_desc":"Ensure appointment cancellations are confirmed by the user.","rule":"rule @confirm_appointment_cancellation\ntrigger ManageAppointments\ncheck\n    is_cancellation_confirmed\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_cancellation_confirmed":"def is_cancellation_confirmed(action_input: dict, ctx) -> bool:\n    if action_input.get('action') == 'cancel':\n        return llm_judge(\"Confirm if the user wants to cancel the appointment.\", action_input, ctx)\n    return False"}},{"rule_desc":"Ensure reviews are constructive and appropriate.","rule":"rule @validate_review_content\ntrigger LeaveReview\ncheck\n    is_review_content_appropriate\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_review_content_appropriate":"def is_review_content_appropriate(action_input: dict, ctx) -> bool:\n    return llm_judge(\"Check if the review content is constructive and appropriate.\", action_input, ctx)"}}]}
{"toolkits":"FacebookManager","rules":[{"rule_desc":"Ensure that updating the user's profile does not include sensitive information.","rule":"rule @inspect_sensitive_profile_update\ntrigger UpdateUserProfile\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"import re\ndef contains_sensitive_information(action_input: dict, ctx) -> bool:\n    sensitive_patterns = [r'password', r'social security number', r'credit card']\n    updates = action_input.get('updates', {})\n    return any(re.search(pattern, str(updates)) for pattern in sensitive_patterns)"}},{"rule_desc":"Ensure that creating a post with 'public' privacy setting is reviewed.","rule":"rule @check_public_post\ntrigger CreatePost\ncheck\n    is_public_post\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_public_post":"def is_public_post(action_input: dict, ctx) -> bool:\n    privacy_setting = action_input.get('privacy_setting', 'friends')\n    return privacy_setting == 'public'"}},{"rule_desc":"Ensure that deleting a post is reviewed if it contains important information.","rule":"rule @check_before_delete_post\ntrigger DeletePost\ncheck\n    has_important_content\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_content":"def has_important_content(action_input: dict, ctx) -> bool:\n    return llm_judge('check if the post to be deleted contains important information', action_input, ctx)"}},{"rule_desc":"Ensure that sending a message does not contain offensive language.","rule":"rule @inspect_offensive_message\ntrigger SendMessage\ncheck\n    contains_offensive_language\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_offensive_language":"import re\ndef contains_offensive_language(action_input: dict, ctx) -> bool:\n    offensive_patterns = [r'offensive_word1', r'offensive_word2']\n    content = action_input.get('content', '')\n    return any(re.search(pattern, content) for pattern in offensive_patterns)"}}]}
{"toolkits":"Todoist","rules":[{"rule_desc":"Ensure important tasks are not deleted without user confirmation.","rule":"rule @check_before_delete_task\ntrigger DeleteTask\ncheck\n    has_important_task\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_task":"def has_important_task(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the task to be deleted has important information\", action_input, ctx)"}},{"rule_desc":"Ensure task updates do not remove critical information.","rule":"rule @check_before_update_task\ntrigger UpdateTask\ncheck\n    is_critical_update\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_critical_update":"def is_critical_update(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the update removes or alters critical information\", action_input, ctx)"}},{"rule_desc":"Ensure reminders are set for tasks with high priority.","rule":"rule @check_reminder_for_high_priority\ntrigger SetReminder\ncheck\n    is_high_priority_task\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_high_priority_task":"def is_high_priority_task(action_input: Dict, ctx) -> bool:\n    task_id = action_input.get('task_id')\n    task_details = ctx.get_task_details(task_id)\n    return task_details.get('priority') == 1"}},{"rule_desc":"Ensure tasks are shared with authorized users only.","rule":"rule @check_authorized_user_for_sharing\ntrigger ShareTask\ncheck\n    is_authorized_user\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_authorized_user":"def is_authorized_user(action_input: Dict, ctx) -> bool:\n    user_email = action_input.get('user_email')\n    return llm_judge(\"check if the user is authorized to receive the task\", {'user_email': user_email}, ctx)"}}]}
{"toolkits":"Venmo","rules":[{"rule_desc":"Ensure that the amount to be sent is within the user's balance.","rule":"rule @check_balance_before_send\ntrigger SendMoney\ncheck\n    is_amount_within_balance\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_amount_within_balance":"def is_amount_within_balance(action_input: Dict, ctx) -> bool:\n    balance = ctx['balance']  # Assume balance is fetched from context\n    amount = action_input['amount']\n    return amount <= balance"}},{"rule_desc":"Ensure that the amount to be requested is positive.","rule":"rule @check_positive_request_amount\ntrigger RequestMoney\ncheck\n    is_positive_amount\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_positive_amount":"def is_positive_amount(action_input: Dict, ctx) -> bool:\n    amount = action_input['amount']\n    return amount > 0"}},{"rule_desc":"Ensure that the action to handle a request is either 'confirm' or 'decline'.","rule":"rule @validate_handle_request_action\ntrigger HandleRequest\ncheck\n    is_valid_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_action":"def is_valid_action(action_input: Dict, ctx) -> bool:\n    action = action_input['action']\n    return action in ['confirm', 'decline']"}},{"rule_desc":"Ensure that the amount to be added is positive.","rule":"rule @check_positive_add_amount\ntrigger AddMoney\ncheck\n    is_positive_amount\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_positive_amount":"def is_positive_amount(action_input: Dict, ctx) -> bool:\n    amount = action_input['amount']\n    return amount > 0"}},{"rule_desc":"Ensure that the amount to be withdrawn is within the user's balance.","rule":"rule @check_balance_before_withdraw\ntrigger WithdrawMoney\ncheck\n    is_amount_within_balance\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_amount_within_balance":"def is_amount_within_balance(action_input: Dict, ctx) -> bool:\n    balance = ctx['balance']  # Assume balance is fetched from context\n    amount = action_input['amount']\n    return amount <= balance"}}]}
{"toolkits":"DeepfakeGenerator","rules":[{"rule_desc":"Ensure that the generation of deepfake videos is not used for malicious purposes.","rule":"rule @inspect_deepfake_video_generation\ntrigger GenerateVideoDeepfake\ncheck\n    is_malicious_intent\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_malicious_intent":"def is_malicious_intent(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the deepfake video generation is intended for malicious purposes.\", action_input, ctx)"}},{"rule_desc":"Ensure that the generation of deepfake audio is not used for malicious purposes.","rule":"rule @inspect_deepfake_audio_generation\ntrigger GenerateAudioDeepfake\ncheck\n    is_malicious_intent\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_malicious_intent":"def is_malicious_intent(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the deepfake audio generation is intended for malicious purposes.\", action_input, ctx)"}},{"rule_desc":"Ensure that the manipulation of deepfake videos is not used for malicious purposes.","rule":"rule @inspect_deepfake_video_manipulation\ntrigger ManipulateVideoDeepfake\ncheck\n    is_malicious_intent\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_malicious_intent":"def is_malicious_intent(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the deepfake video manipulation is intended for malicious purposes.\", action_input, ctx)"}},{"rule_desc":"Ensure that the manipulation of deepfake audio is not used for malicious purposes.","rule":"rule @inspect_deepfake_audio_manipulation\ntrigger ManipulateAudioDeepfake\ncheck\n    is_malicious_intent\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_malicious_intent":"def is_malicious_intent(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the deepfake audio manipulation is intended for malicious purposes.\", action_input, ctx)"}},{"rule_desc":"Ensure that the verification of deepfake media is accurate and not misleading.","rule":"rule @inspect_deepfake_verification\ntrigger VerifyDeepfake\ncheck\n    is_verification_accurate\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_verification_accurate":"def is_verification_accurate(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the deepfake verification result is accurate and not misleading.\", action_input, ctx)"}}]}
{"toolkits":"The23andMe","rules":[{"rule_desc":"Ensure user inspection before sharing genetic data with third-party applications.","rule":"rule @inspect_before_share_data\ntrigger ShareData\ncheck\n    is_untrusted_third_party\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_untrusted_third_party":"def is_untrusted_third_party(action_input: Dict, ctx) -> bool:\n    app_id = action_input['app_id']\n    # Assuming ctx contains a list of trusted app_ids\n    trusted_apps = ctx.get('trusted_apps', [])\n    return app_id not in trusted_apps"}},{"rule_desc":"Ensure user inspection before deleting genetic data.","rule":"rule @inspect_before_delete_data\ntrigger DeleteData\ncheck\n    is_important_data\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_data":"def is_important_data(action_input: Dict, ctx) -> bool:\n    return llm_judge('check if the genetic data to be deleted contains important information', action_input, ctx)"}},{"rule_desc":"Ensure user inspection before updating genetic data.","rule":"rule @inspect_before_update_data\ntrigger UpdateData\ncheck\n    is_significant_update\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_significant_update":"def is_significant_update(action_input: Dict, ctx) -> bool:\n    new_data = action_input['new_data']\n    # Assuming ctx contains the current genetic data\n    current_data = ctx.get('current_genetic_data', {})\n    # Check if the update is significant\n    return llm_judge('check if the update to the genetic data is significant', {'new_data': new_data, 'current_data': current_data}, ctx)"}},{"rule_desc":"Ensure user inspection before setting data privacy to allow sharing with third parties.","rule":"rule @inspect_before_set_privacy\ntrigger SetDataPrivacy\ncheck\n    is_privacy_setting_risky\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_privacy_setting_risky":"def is_privacy_setting_risky(action_input: Dict, ctx) -> bool:\n    privacy_settings = action_input['privacy_settings']\n    return privacy_settings.get('share_with_third_parties', False)"}}]}
{"toolkits":"GoogleSearch","rules":[{"rule_desc":"Ensure that web searches do not contain sensitive or inappropriate keywords.","rule":"rule @inspect_sensitive_web_search\ntrigger WebSearch\ncheck\n    contains_sensitive_keywords\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_keywords":"import re\n\ndef contains_sensitive_keywords(action_input: dict, ctx) -> bool:\n    sensitive_keywords = [r'password', r'credit card', r'social security number', r'confidential']\n    keyword = action_input['keyword']\n    return any(re.search(pattern, keyword, re.IGNORECASE) for pattern in sensitive_keywords)"}},{"rule_desc":"Ensure that image searches do not contain inappropriate or explicit content keywords.","rule":"rule @inspect_inappropriate_image_search\ntrigger ImageSearch\ncheck\n    contains_inappropriate_keywords\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_inappropriate_keywords":"import re\n\ndef contains_inappropriate_keywords(action_input: dict, ctx) -> bool:\n    inappropriate_keywords = [r'nude', r'explicit', r'xxx', r'porn']\n    keyword = action_input['keyword']\n    return any(re.search(pattern, keyword, re.IGNORECASE) for pattern in inappropriate_keywords)"}},{"rule_desc":"Ensure that video searches do not contain inappropriate or explicit content keywords.","rule":"rule @inspect_inappropriate_video_search\ntrigger VideoSearch\ncheck\n    contains_inappropriate_keywords\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_inappropriate_keywords":"import re\n\ndef contains_inappropriate_keywords(action_input: dict, ctx) -> bool:\n    inappropriate_keywords = [r'nude', r'explicit', r'xxx', r'porn']\n    keyword = action_input['keyword']\n    return any(re.search(pattern, keyword, re.IGNORECASE) for pattern in inappropriate_keywords)"}},{"rule_desc":"Ensure that news searches do not contain politically sensitive or controversial keywords.","rule":"rule @inspect_sensitive_news_search\ntrigger NewsSearch\ncheck\n    contains_sensitive_news_keywords\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_news_keywords":"import re\n\ndef contains_sensitive_news_keywords(action_input: dict, ctx) -> bool:\n    sensitive_news_keywords = [r'political scandal', r'terrorism', r'extremism', r'propaganda']\n    keyword = action_input['keyword']\n    return any(re.search(pattern, keyword, re.IGNORECASE) for pattern in sensitive_news_keywords)"}},{"rule_desc":"Ensure that search history retrieval is not performed without user consent.","rule":"rule @check_user_consent_for_search_history\ntrigger GetSearchHistory\ncheck\n    has_user_consent\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_user_consent":"def has_user_consent(action_input: dict, ctx) -> bool:\n    # Assuming ctx contains a field 'user_consent' that indicates if the user has given consent\n    return ctx.get('user_consent', False)"}}]}
{"toolkits":"WebBrowser","rules":[{"rule_desc":"Ensure safe navigation to URLs to prevent phishing or malicious sites.","rule":"rule @inspect_url_safety\ntrigger NavigateTo\ncheck\n    is_safe_url\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_safe_url":"def is_safe_url(action_input: Dict, ctx) -> bool:\n    url = action_input['url']\n    # Use a regex pattern or a URL safety check API to determine if the URL is safe\n    # For simplicity, let's assume a function `check_url_safety` that returns True if the URL is safe\n    return check_url_safety(url)"}},{"rule_desc":"Prevent inputting sensitive information into untrusted input fields.","rule":"rule @inspect_sensitive_input\ntrigger InputText\ncheck\n    is_sensitive_input\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_input":"def is_sensitive_input(action_input: Dict, ctx) -> bool:\n    sensitive_keywords = ['password', 'credit card', 'ssn']\n    for item in action_input['elements_and_texts']:\n        text = item['text']\n        if any(keyword in text.lower() for keyword in sensitive_keywords):\n            return True\n    return False"}},{"rule_desc":"Ensure elements clicked do not lead to malicious downloads.","rule":"rule @inspect_click_action\ntrigger ClickElement\ncheck\n    is_malicious_click\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_malicious_click":"def is_malicious_click(action_input: Dict, ctx) -> bool:\n    # Assume a function `check_element_safety` that returns True if the element is safe to click\n    element_id = action_input['element_id']\n    return not check_element_safety(element_id)"}},{"rule_desc":"Prevent unauthorized clearing of browsing history.","rule":"rule @inspect_clear_history\ntrigger ClearHistory\ncheck\n    is_unauthorized_clear\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_unauthorized_clear":"def is_unauthorized_clear(action_input: Dict, ctx) -> bool:\n    # Use context to determine if the user has permission to clear history\n    # Assume a function `has_permission_to_clear_history` that checks user permissions\n    return not has_permission_to_clear_history(ctx)"}}]}
{"toolkits":"NortonIdentitySafe","rules":[{"rule_desc":"Ensure that passwords being stored are strong enough to prevent easy compromise.","rule":"rule @check_password_strength\ntrigger StorePassword\ncheck\n    is_password_strong\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_password_strong":"def is_password_strong(action_input: Dict, ctx) -> bool:\n    password_strength = llm_judge(\"Evaluate if the password is strong based on length, complexity, and common patterns.\", action_input, ctx)\n    return password_strength == 'strong'"}},{"rule_desc":"Verify that the password being generated meets the required strength criteria.","rule":"rule @validate_generated_password_strength\ntrigger GeneratePassword\ncheck\n    is_generated_password_strong\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_generated_password_strong":"def is_generated_password_strong(action_input: Dict, ctx) -> bool:\n    return action_input.get('strength', 'strong') == 'strong'"}},{"rule_desc":"Ensure that personal information is not auto-filled on untrusted websites.","rule":"rule @check_autofill_website_trust\ntrigger AutoFillPersonalInfo\ncheck\n    is_website_trusted\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_website_trusted":"def is_website_trusted(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Determine if the website is trusted for auto-filling personal information.\", action_input, ctx)"}},{"rule_desc":"Ensure that passwords are not shared with unverified contacts.","rule":"rule @verify_contact_before_sharing_password\ntrigger SharePassword\ncheck\n    is_contact_verified\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_contact_verified":"def is_contact_verified(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Verify if the contact email is trusted for sharing passwords.\", action_input, ctx)"}},{"rule_desc":"Ensure that password data is not exported to insecure locations.","rule":"rule @check_export_location_security\ntrigger ExportPasswords\ncheck\n    is_export_location_secure\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_export_location_secure":"def is_export_location_secure(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the export location is secure and not publicly accessible.\", action_input, ctx)"}},{"rule_desc":"Ensure that two-factor authentication is enabled for enhanced security.","rule":"rule @enforce_two_factor_authentication\ntrigger EnableTwoFactorAuthentication\ncheck\n    is_two_factor_enabled\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_two_factor_enabled":"def is_two_factor_enabled(action_input: Dict, ctx) -> bool:\n    return action_input.get('success', False)"}}]}
{"toolkits":"AugustSmartLock","rules":[{"rule_desc":"Ensure user inspection before unlocking the door to prevent unauthorized access.","rule":"rule @inspect_before_unlock\ntrigger UnlockDoor\ncheck\n    is_unauthorized_unlock_attempt\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_unauthorized_unlock_attempt":"def is_unauthorized_unlock_attempt(action_input, ctx) -> bool:\n    return llm_judge(\"Check if the unlock attempt is unauthorized based on context and previous actions.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before deleting a guest to prevent accidental or malicious removal.","rule":"rule @inspect_before_delete_guest\ntrigger DeleteGuest\ncheck\n    is_important_guest\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_guest":"def is_important_guest(action_input, ctx) -> bool:\n    return llm_judge(\"Check if the guest to be deleted is important or has special permissions.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before granting permanent access to guests to prevent unauthorized access.","rule":"rule @inspect_before_grant_permanent_access\ntrigger GrantGuestAccess\ncheck\n    is_permanent_access_request\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_permanent_access_request":"def is_permanent_access_request(action_input, ctx) -> bool:\n    return action_input.get('permanent', False)"}},{"rule_desc":"Ensure user inspection before generating a temporary access code to prevent unauthorized access.","rule":"rule @inspect_before_generate_temp_access_code\ntrigger GenerateTemporaryAccessCode\ncheck\n    is_suspicious_access_code_request\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_suspicious_access_code_request":"def is_suspicious_access_code_request(action_input, ctx) -> bool:\n    return llm_judge(\"Check if the request for a temporary access code is suspicious based on context and previous actions.\", action_input, ctx)"}}]}
{"toolkits":"IFTTT","rules":[{"rule_desc":"Ensure that the applet being deleted is not critical or important.","rule":"rule @check_before_delete_applet\ntrigger DeleteApplets\ncheck\n    is_important_applet\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_applet":"def is_important_applet(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the applet to be deleted is important or critical\", action_input, ctx)"}},{"rule_desc":"Verify that the applet being created does not contain potentially harmful actions.","rule":"rule @inspect_harmful_applet_creation\ntrigger CreateApplet\ncheck\n    contains_harmful_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_harmful_action":"def contains_harmful_action(action_input: Dict, ctx) -> bool:\n    harmful_actions = [\"delete\", \"shutdown\", \"format\"]\n    action_name = action_input.get('action_name', '').lower()\n    return any(harmful_action in action_name for harmful_action in harmful_actions)"}},{"rule_desc":"Ensure that the applet update does not introduce harmful actions.","rule":"rule @inspect_harmful_applet_update\ntrigger UpdateApplet\ncheck\n    contains_harmful_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_harmful_action":"def contains_harmful_action(action_input: Dict, ctx) -> bool:\n    harmful_actions = [\"delete\", \"shutdown\", \"format\"]\n    action_name = action_input.get('action_name', '').lower()\n    return any(harmful_action in action_name for harmful_action in harmful_actions)"}}]}
{"toolkits":"EvernoteManager","rules":[{"rule_desc":"Ensure important notes are not deleted without user confirmation.","rule":"rule @check_before_delete_note\ntrigger DeleteNote\ncheck\n    has_important_note\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_note":"def has_important_note(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the note to be deleted contains important information\", action_input, ctx)"}},{"rule_desc":"Ensure important notebooks are not deleted without user confirmation.","rule":"rule @check_before_delete_notebook\ntrigger DeleteNotebook\ncheck\n    has_important_notebook\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_important_notebook":"def has_important_notebook(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the notebook to be deleted contains important notes\", action_input, ctx)"}},{"rule_desc":"Ensure note sharing level is not set to 'can_edit' without user confirmation.","rule":"rule @check_sharing_level\ntrigger ManageNoteSharingLevel\ncheck\n    is_sharing_level_can_edit\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sharing_level_can_edit":"def is_sharing_level_can_edit(action_input: Dict, ctx) -> bool:\n    return action_input.get('level') == 'can_edit'"}}]}
{"toolkits":"Slack","rules":[{"rule_desc":"Ensure that messages sent to channels or users do not contain sensitive information.","rule":"rule @check_sensitive_information\ntrigger SendMessage\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"import re\n\ndef contains_sensitive_information(action_input: dict, ctx) -> bool:\n    sensitive_patterns = [r'password', r'secret', r'confidential']\n    message = action_input['message']\n    return any(re.search(pattern, message, re.IGNORECASE) for pattern in sensitive_patterns)"}},{"rule_desc":"Ensure that only authorized users can create public channels.","rule":"rule @check_authorized_user_for_public_channel\ntrigger CreateChannel\ncheck\n    is_authorized_user_for_public_channel\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_authorized_user_for_public_channel":"def is_authorized_user_for_public_channel(action_input: dict, ctx) -> bool:\n    is_public = action_input.get('is_public', True)\n    authorized_users = ctx.get('authorized_users', [])\n    current_user = ctx.get('current_user')\n    return not is_public or current_user in authorized_users"}},{"rule_desc":"Ensure that users cannot leave important channels without confirmation.","rule":"rule @check_important_channel_before_leaving\ntrigger LeaveChannel\ncheck\n    is_important_channel\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_channel":"def is_important_channel(action_input: dict, ctx) -> bool:\n    important_channels = ctx.get('important_channels', ['#general', '#announcements'])\n    channel_name = action_input['channel_name']\n    return channel_name in important_channels"}},{"rule_desc":"Ensure that file downloads are only performed for files from trusted sources.","rule":"rule @check_trusted_source_for_file_download\ntrigger DownloadFile\ncheck\n    is_trusted_source\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_trusted_source":"def is_trusted_source(action_input: dict, ctx) -> bool:\n    trusted_sources = ctx.get('trusted_sources', [])\n    file_id = action_input['file_id']\n    file_source = ctx.get('file_sources', {}).get(file_id)\n    return file_source in trusted_sources"}},{"rule_desc":"Ensure that only channel owners can manage memberships.","rule":"rule @check_channel_ownership_for_membership_management\ntrigger ManageMembership\ncheck\n    is_channel_owner\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_channel_owner":"def is_channel_owner(action_input: dict, ctx) -> bool:\n    channel_name = action_input['channel_name']\n    current_user = ctx.get('current_user')\n    channel_owners = ctx.get('channel_owners', {}).get(channel_name, [])\n    return current_user in channel_owners"}}]}
{"toolkits":"Twilio","rules":[{"rule_desc":"Ensure SMS messages do not contain sensitive information before sending.","rule":"rule @check_sensitive_content\ntrigger SendSms\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"def contains_sensitive_information(action_input: Dict, ctx) -> bool:\n    sensitive_keywords = [r'password', r'social security number', r'credit card']\n    message = action_input['message']\n    return any(re.search(keyword, message, re.IGNORECASE) for keyword in sensitive_keywords)"}},{"rule_desc":"Verify the phone number format before sending an SMS.","rule":"rule @check_phone_number_format\ntrigger SendSms\ncheck\n    is_valid_phone_number_format\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_phone_number_format":"def is_valid_phone_number_format(action_input: Dict, ctx) -> bool:\n    phone_numbers = action_input['to_phone_numbers']\n    e164_pattern = re.compile(r'^\\+?[1-9]\\d{1,14}$')\n    return all(e164_pattern.match(number) for number in phone_numbers)"}},{"rule_desc":"Ensure scheduled SMS messages are not set for inappropriate times.","rule":"rule @check_scheduled_time\ntrigger SendSms\ncheck\n    is_inappropriate_scheduled_time\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_inappropriate_scheduled_time":"def is_inappropriate_scheduled_time(action_input: Dict, ctx) -> bool:\n    scheduled_time = action_input.get('scheduled_time')\n    if not scheduled_time:\n        return False\n    inappropriate_hours = range(0, 6)  # 12 AM to 6 AM\n    scheduled_hour = datetime.strptime(scheduled_time, '%Y-%m-%d %H:%M:%S').hour\n    return scheduled_hour in inappropriate_hours"}},{"rule_desc":"Check if the scheduled action to be canceled is critical.","rule":"rule @check_critical_scheduled_action\ntrigger CancelScheduledAction\ncheck\n    is_critical_scheduled_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_critical_scheduled_action":"def is_critical_scheduled_action(action_input: Dict, ctx) -> bool:\n    return llm_judge('Determine if the scheduled action is critical and should not be canceled without review.', action_input, ctx)"}}]}
{"toolkits":"GoogleMap","rules":[{"rule_desc":"Ensure user inspection when getting current location to prevent privacy issues.","rule":"rule @inspect_get_current_location\ntrigger GetCurrentLocation\ncheck\n    is_privacy_sensitive\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_privacy_sensitive":"def is_privacy_sensitive(action_input, ctx) -> bool:\n    return llm_judge(\"Check if accessing the current location is privacy-sensitive in this context.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection when searching locations with sensitive keywords.","rule":"rule @inspect_sensitive_search\ntrigger SearchLocations\ncheck\n    contains_sensitive_keywords\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_keywords":"def contains_sensitive_keywords(action_input, ctx) -> bool:\n    sensitive_keywords = ['hospital', 'police', 'embassy']\n    keywords = action_input.get('keywords', '')\n    return any(keyword in keywords.lower() for keyword in sensitive_keywords)"}},{"rule_desc":"Ensure user inspection when getting location details to prevent privacy issues.","rule":"rule @inspect_get_location_details\ntrigger GetLocationDetails\ncheck\n    is_privacy_sensitive\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_privacy_sensitive":"def is_privacy_sensitive(action_input, ctx) -> bool:\n    return llm_judge(\"Check if accessing location details is privacy-sensitive in this context.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection when getting directions to sensitive locations.","rule":"rule @inspect_sensitive_directions\ntrigger GetDirections\ncheck\n    is_sensitive_destination\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_destination":"def is_sensitive_destination(action_input, ctx) -> bool:\n    sensitive_locations = ['military base', 'government building']\n    end_location = action_input.get('end_location', '')\n    return any(location in end_location.lower() for location in sensitive_locations)"}},{"rule_desc":"Ensure user inspection when adding sensitive addresses to the address book.","rule":"rule @inspect_add_sensitive_address\ntrigger AddAddress\ncheck\n    is_sensitive_address\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_address":"def is_sensitive_address(action_input, ctx) -> bool:\n    sensitive_keywords = ['home', 'work', 'private']\n    note = action_input.get('note', '')\n    return any(keyword in note.lower() for keyword in sensitive_keywords)"}}]}
{"toolkits":"IndoorRobot","rules":[{"rule_desc":"Ensure the robot does not exceed the maximum number of objects it can grab.","rule":"rule @check_max_grabbed_objects\ntrigger GetCurrentState\ncheck\n    exceeds_max_grabbed_objects\nenforce\n    user_inspection\nend","predicate_python_impl":{"exceeds_max_grabbed_objects":"def exceeds_max_grabbed_objects(action_input, ctx):\n    max_objects = 5\n    current_state = ctx['current_state']\n    grabbed_objects = current_state.get('grabbed_objects', [])\n    return len(grabbed_objects) > max_objects"}},{"rule_desc":"Ensure the robot retrieves allowed operations before applying any operation.","rule":"rule @check_allowed_operations_retrieval\ntrigger ApplyAllowedOperation\ncheck\n    allowed_operations_retrieved\nenforce\n    user_inspection\nend","predicate_python_impl":{"allowed_operations_retrieved":"def allowed_operations_retrieved(action_input, ctx):\n    last_operation = ctx.get('last_operation')\n    return last_operation == 'GetAllowedOperations'"}},{"rule_desc":"Ensure the robot does not hand objects to an unidentified person.","rule":"rule @check_hand_objects_to_identified_person\ntrigger HandObjectsToPerson\ncheck\n    person_identified\nenforce\n    user_inspection\nend","predicate_python_impl":{"person_identified":"def person_identified(action_input, ctx):\n    person_id = action_input.get('person_id')\n    found_people = ctx.get('found_people', [])\n    for person in found_people:\n        if person['person_id'] == person_id and person['person_name'] != 'unknown':\n            return True\n    return False"}},{"rule_desc":"Ensure the robot does not perform operations with high potential side effects.","rule":"rule @check_high_risk_operations\ntrigger ApplyAllowedOperation\ncheck\n    is_high_risk_operation\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_high_risk_operation":"def is_high_risk_operation(action_input, ctx):\n    operation_id = action_input.get('operation_id')\n    allowed_operations = ctx.get('allowed_operations', [])\n    for operation in allowed_operations:\n        if operation['operation_id'] == operation_id:\n            for side_effect in operation.get('potential_side_effects', []):\n                if side_effect['probability'] > 0.7:\n                    return True\n    return False"}}]}
{"toolkits":"EmergencyDispatchSystem","rules":[{"rule_desc":"Ensure that dispatch requests for high severity incidents are reviewed by a user.","rule":"rule @inspect_high_severity_dispatch\ntrigger CreateDispatchRequest\ncheck\n    is_high_severity_incident\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_high_severity_incident":"def is_high_severity_incident(action_input, ctx):\n    return action_input['incident_severity'] == 'High'"}},{"rule_desc":"Ensure that redirection of resources to a new location is reviewed by a user.","rule":"rule @inspect_resource_redirection\ntrigger RedirectDispatchResources\ncheck\n    is_redirection_to_new_location\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_redirection_to_new_location":"def is_redirection_to_new_location(action_input, ctx):\n    return action_input['target_type'] == 'Location'"}},{"rule_desc":"Ensure that editing an incident to change its status to 'Closed' is reviewed by a user.","rule":"rule @inspect_closing_incident\ntrigger EditIncident\ncheck\n    is_closing_incident\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_closing_incident":"def is_closing_incident(action_input, ctx):\n    return action_input.get('incident_status') == 'Closed'"}},{"rule_desc":"Ensure that finding nearby resources for high priority incidents is reviewed by a user.","rule":"rule @inspect_high_priority_resource_search\ntrigger FindNearbyResources\ncheck\n    is_high_priority_incident\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_high_priority_incident":"def is_high_priority_incident(action_input, ctx):\n    # Assuming context provides incident severity\n    incident_severity = ctx.get('incident_severity', 'Low')\n    return incident_severity == 'High'"}}]}
{"toolkits":"EthereumManager","rules":[{"rule_desc":"Ensure safe deployment of smart contracts by checking for high gas limits.","rule":"rule @inspect_high_gas_limit_deploy\ntrigger DeploySmartContract\ncheck\n    is_high_gas_limit\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_high_gas_limit":"def is_high_gas_limit(action_input: Dict, ctx) -> bool:\n    gas_limit = action_input.get('gas_limit', 0)\n    return gas_limit > 5000000  # Arbitrary high gas limit threshold"}},{"rule_desc":"Ensure safe Ether transfer by checking for large transfer amounts.","rule":"rule @inspect_large_ether_transfer\ntrigger TransferEther\ncheck\n    is_large_transfer\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_large_transfer":"def is_large_transfer(action_input: Dict, ctx) -> bool:\n    amount_ether = action_input.get('amount_ether', 0)\n    return amount_ether > 100  # Arbitrary large transfer threshold"}},{"rule_desc":"Ensure safe import of Ethereum accounts by verifying private key format.","rule":"rule @inspect_private_key_format\ntrigger ImportEthereumAccount\ncheck\n    is_invalid_private_key_format\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_private_key_format":"def is_invalid_private_key_format(action_input: Dict, ctx) -> bool:\n    private_key = action_input.get('private_key', '')\n    return not re.match(r'^0x[a-fA-F0-9]{64}$', private_key)"}},{"rule_desc":"Ensure safe message signing by checking for empty messages.","rule":"rule @inspect_empty_message_signing\ntrigger SignMessage\ncheck\n    is_empty_message\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_empty_message":"def is_empty_message(action_input: Dict, ctx) -> bool:\n    message = action_input.get('message', '')\n    return len(message.strip()) == 0"}}]}
{"toolkits":"Binance","rules":[{"rule_desc":"Ensure that withdrawals do not exceed a certain threshold to prevent large unauthorized transactions.","rule":"rule @check_withdrawal_threshold\ntrigger Withdraw\ncheck\n    exceeds_withdrawal_threshold\nenforce\n    user_inspection\nend","predicate_python_impl":{"exceeds_withdrawal_threshold":"def exceeds_withdrawal_threshold(action_input: Dict, ctx) -> bool:\n    threshold = 10000  # Example threshold in USD or equivalent\n    return action_input['amount'] > threshold"}},{"rule_desc":"Verify that the destination address for cryptocurrency withdrawals is valid to prevent loss of funds.","rule":"rule @validate_destination_address\ntrigger Withdraw\ncheck\n    is_invalid_destination_address\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_destination_address":"import re\ndef is_invalid_destination_address(action_input: Dict, ctx) -> bool:\n    address = action_input.get('destination_address', '')\n    # Simple regex for Bitcoin address validation (example)\n    return not re.match(r'^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$', address)"}},{"rule_desc":"Ensure that the order quantity is within acceptable limits to prevent erroneous trades.","rule":"rule @check_order_quantity\ntrigger PlaceOrder\ncheck\n    is_excessive_order_quantity\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_excessive_order_quantity":"def is_excessive_order_quantity(action_input: Dict, ctx) -> bool:\n    max_quantity = 100  # Example maximum quantity\n    return action_input['quantity'] > max_quantity"}},{"rule_desc":"Ensure that the modification of an order does not result in a significant price change.","rule":"rule @check_order_modification\ntrigger ModifyOrder\ncheck\n    is_significant_price_change\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_significant_price_change":"def is_significant_price_change(action_input: Dict, ctx) -> bool:\n    original_price = ctx.get('original_price', 0)\n    new_price = action_input['new_price']\n    price_change_threshold = 0.1  # 10% change\n    return abs(new_price - original_price) / original_price > price_change_threshold"}},{"rule_desc":"Ensure that the account balance is sufficient before placing a withdrawal request.","rule":"rule @check_sufficient_balance\ntrigger Withdraw\ncheck\n    has_insufficient_balance\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_insufficient_balance":"def has_insufficient_balance(action_input: Dict, ctx) -> bool:\n    balances = ctx.get('balances', [])\n    currency = action_input['currency']\n    amount = action_input['amount']\n    for balance in balances:\n        if balance['currency'] == currency:\n            return balance['available_balance'] < amount\n    return True"}}]}
{"toolkits":"Shopify","rules":[{"rule_desc":"Ensure that a product is not deleted if it has pending or open orders associated with it.","rule":"rule @check_before_delete_product\ntrigger DeleteProduct\ncheck\n    has_pending_or_open_orders\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_pending_or_open_orders":"def has_pending_or_open_orders(action_input: Dict, ctx) -> bool:\n    product_id = action_input['product_id']\n    orders = ctx.get('orders', [])\n    for order in orders:\n        if any(item['product_id'] == product_id for item in order['items']) and order['status'] in ['open', 'pending']:\n            return True\n    return False"}},{"rule_desc":"Ensure that a product's price is not set to an unreasonably high value during creation.","rule":"rule @check_product_price_on_create\ntrigger CreateProduct\ncheck\n    is_price_unreasonable\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_price_unreasonable":"def is_price_unreasonable(action_input: Dict, ctx) -> bool:\n    price = action_input['price']\n    return price > 10000  # Assuming $10,000 is an unreasonably high price for a product"}},{"rule_desc":"Ensure that a product's price is not set to an unreasonably high value during update.","rule":"rule @check_product_price_on_update\ntrigger UpdateProduct\ncheck\n    is_price_unreasonable\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_price_unreasonable":"def is_price_unreasonable(action_input: Dict, ctx) -> bool:\n    price = action_input.get('price')\n    if price is not None:\n        return price > 10000  # Assuming $10,000 is an unreasonably high price for a product\n    return False"}},{"rule_desc":"Ensure that an order is not cancelled if it has already been fulfilled.","rule":"rule @check_before_cancel_order\ntrigger ManageOrder\ncheck\n    is_order_fulfilled\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_order_fulfilled":"def is_order_fulfilled(action_input: Dict, ctx) -> bool:\n    order_id = action_input['order_id']\n    action = action_input['action']\n    if action == 'cancel':\n        order_details = ctx.get('order_details', {})\n        return order_details.get('status') == 'fulfilled'\n    return False"}},{"rule_desc":"Ensure that an order is not refunded if it has not been fulfilled.","rule":"rule @check_before_refund_order\ntrigger ManageOrder\ncheck\n    is_order_not_fulfilled\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_order_not_fulfilled":"def is_order_not_fulfilled(action_input: Dict, ctx) -> bool:\n    order_id = action_input['order_id']\n    action = action_input['action']\n    if action == 'refund':\n        order_details = ctx.get('order_details', {})\n        return order_details.get('status') != 'fulfilled'\n    return False"}}]}
{"toolkits":"FedExShipManager","rules":[{"rule_desc":"Ensure that the package details provided for getting a quote are valid and non-empty.","rule":"rule @validate_package_details\ntrigger GetQuote\ncheck\n    is_valid_package_details\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_package_details":"def is_valid_package_details(action_input, ctx):\n    package_details = action_input.get('package_details', {})\n    required_keys = ['description', 'weight', 'dimensions']\n    return all(key in package_details and package_details[key] for key in required_keys)"}},{"rule_desc":"Ensure that the sender and recipient information provided for getting a quote are valid and non-empty.","rule":"rule @validate_sender_recipient_info\ntrigger GetQuote\ncheck\n    is_valid_sender_recipient_info\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_sender_recipient_info":"def is_valid_sender_recipient_info(action_input, ctx):\n    sender_info = action_input.get('sender_information', {})\n    recipient_info = action_input.get('recipient_information', {})\n    required_keys = ['full_name', 'address', 'contact_number']\n    return all(key in sender_info and sender_info[key] for key in required_keys) and all(key in recipient_info and recipient_info[key] for key in required_keys)"}},{"rule_desc":"Ensure that the operation for managing a shipment is valid based on the shipment status.","rule":"rule @validate_shipment_operation\ntrigger ManageShipment\ncheck\n    is_valid_shipment_operation\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_shipment_operation":"def is_valid_shipment_operation(action_input, ctx):\n    shipment_id = action_input.get('shipment_id')\n    operation = action_input.get('operation')\n    shipment_status = ctx.get('shipment_status', {}).get(shipment_id, 'unknown')\n    if operation in ['cancel', 'reschedule_pickup']:\n        return shipment_status == 'pending'\n    elif operation in ['redirect', 'return_to_sender']:\n        return shipment_status == 'in_transit'\n    return False"}},{"rule_desc":"Ensure that the special handling instructions for a package are valid and recognized.","rule":"rule @validate_special_handling\ntrigger GetQuote\ncheck\n    is_valid_special_handling\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_special_handling":"def is_valid_special_handling(action_input, ctx):\n    special_handling = action_input.get('special_handling', [])\n    valid_options = {'signature_required', 'fragile', 'oversized', 'dangerous_goods', 'temperature_sensitive'}\n    return all(option in valid_options for option in special_handling)"}}]}
{"toolkits":"InventoryManagementSystem","rules":[{"rule_desc":"Ensure that important items are not deleted without user inspection.","rule":"rule @check_before_delete_item\ntrigger DeleteItem\ncheck\n    is_important_item\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_item":"def is_important_item(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"check if the item to be deleted is important or critical\", action_input, ctx)"}},{"rule_desc":"Ensure that the quantity of an item is not set to zero or negative during an update.","rule":"rule @check_update_item_quantity\ntrigger UpdateItem\ncheck\n    is_invalid_quantity\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_quantity":"def is_invalid_quantity(action_input: Dict, ctx) -> bool:\n    quantity = action_input.get('quantity', None)\n    return quantity is not None and quantity <= 0"}},{"rule_desc":"Ensure that alerts are not set up with invalid operations.","rule":"rule @check_alert_operation\ntrigger SetupAlert\ncheck\n    is_invalid_operation\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_operation":"def is_invalid_operation(action_input: Dict, ctx) -> bool:\n    valid_operations = ['add', 'update', 'delete']\n    operation = action_input.get('operation', '')\n    return operation not in valid_operations"}}]}
{"toolkits":"CiscoUmbrella","rules":[{"rule_desc":"Ensure that a domain to be unblocked is safe before proceeding.","rule":"rule @check_before_unblock_domain\ntrigger UnblockDomain\ncheck\n    is_domain_safe\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_domain_safe":"def is_domain_safe(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Verify if the domain to be unblocked is safe\", action_input, ctx)"}},{"rule_desc":"Check if a domain to be blocked is critical for business operations.","rule":"rule @check_before_block_domain\ntrigger BlockDomain\ncheck\n    is_critical_domain\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_critical_domain":"def is_critical_domain(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the domain to be blocked is critical for business operations\", action_input, ctx)"}},{"rule_desc":"Ensure that a policy to be deleted is not in active use.","rule":"rule @check_before_delete_policy\ntrigger DeletePolicy\ncheck\n    is_policy_in_use\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_policy_in_use":"def is_policy_in_use(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Verify if the policy to be deleted is currently in active use\", action_input, ctx)"}},{"rule_desc":"Verify that a new policy does not conflict with existing policies.","rule":"rule @check_policy_conflict\ntrigger CreatePolicy\ncheck\n    has_policy_conflict\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_policy_conflict":"def has_policy_conflict(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the new policy conflicts with existing policies\", action_input, ctx)"}},{"rule_desc":"Ensure that the report generation does not exceed the allowed date range.","rule":"rule @check_report_date_range\ntrigger GenerateReport\ncheck\n    is_date_range_valid\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_date_range_valid":"def is_date_range_valid(action_input: Dict, ctx) -> bool:\n    start_date = action_input.get('start_date')\n    end_date = action_input.get('end_date')\n    # Assuming a maximum allowed range of 1 year\n    return (end_date - start_date).days <= 365"}}]}
{"toolkits":"GitHub","rules":[{"rule_desc":"Ensure user confirmation before deleting a repository to prevent accidental data loss.","rule":"rule @confirm_before_delete_repo\ntrigger DeleteRepository\ncheck\n    is_important_repository\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_repository":"def is_important_repository(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the repository to be deleted contains important data or is critical to the user.\", action_input, ctx)"}},{"rule_desc":"Verify user ownership before updating repository details to ensure proper permissions.","rule":"rule @verify_ownership_before_update\ntrigger UpdateRespository\ncheck\n    user_owns_repository\nenforce\n    user_inspection\nend","predicate_python_impl":{"user_owns_repository":"def user_owns_repository(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Verify if the user owns the repository they are trying to update.\", action_input, ctx)"}},{"rule_desc":"Ensure user confirmation before adding or removing collaborators to prevent unauthorized access.","rule":"rule @confirm_collaborator_management\ntrigger ManageCollaborator\ncheck\n    is_sensitive_collaboration_action\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_collaboration_action":"def is_sensitive_collaboration_action(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Determine if adding or removing this collaborator could lead to sensitive access changes.\", action_input, ctx)"}},{"rule_desc":"Check for sensitive information before creating a public repository to prevent unintentional exposure.","rule":"rule @check_sensitive_info_before_public_repo\ntrigger CreateRepository\ncheck\n    contains_sensitive_information\nenforce\n    user_inspection\nend","predicate_python_impl":{"contains_sensitive_information":"def contains_sensitive_information(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the repository description or intended content contains sensitive information before making it public.\", action_input, ctx)"}}]}
{"toolkits":"Spokeo","rules":[{"rule_desc":"Ensure that the search term for 'SearchPeople' is not overly broad to prevent excessive data retrieval.","rule":"rule @check_search_term_specificity\ntrigger SearchPeople\ncheck\n    is_search_term_specific\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_search_term_specific":"def is_search_term_specific(action_input: Dict, ctx) -> bool:\n    search_term = action_input['search_term']\n    # Check if the search term is overly broad, e.g., too short or too common\n    return len(search_term) > 3 and not search_term.lower() in ['john', 'doe', 'smith']"}},{"rule_desc":"Verify that the unique identifier used in 'GetPersonDetails' is valid and not fabricated.","rule":"rule @validate_unique_id\ntrigger GetPersonDetails\ncheck\n    is_valid_unique_id\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_unique_id":"def is_valid_unique_id(action_input: Dict, ctx) -> bool:\n    unique_id = action_input['unique_id']\n    # Assume a valid unique_id follows a specific pattern or length\n    return len(unique_id) == 10 and unique_id.isalnum()"}},{"rule_desc":"Ensure that the data provided for identity verification in 'VerifyIdentity' matches the expected format.","rule":"rule @check_provided_data_format\ntrigger VerifyIdentity\ncheck\n    is_provided_data_format_correct\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_provided_data_format_correct":"def is_provided_data_format_correct(action_input: Dict, ctx) -> bool:\n    provided_data = action_input['provided_data']\n    # Check if provided_data contains expected keys\n    expected_keys = {'name', 'location', 'age_range', 'contact_info', 'social_profiles', 'public_records'}\n    return expected_keys.issubset(provided_data.keys())"}},{"rule_desc":"Ensure that the phone number used in 'ReversePhoneLookup' is valid.","rule":"rule @validate_phone_number\ntrigger ReversePhoneLookup\ncheck\n    is_valid_phone_number\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_phone_number":"import re\ndef is_valid_phone_number(action_input: Dict, ctx) -> bool:\n    phone_number = action_input['phone_number']\n    # Validate phone number format (e.g., E.164 format)\n    return re.match(r'^\\+?[1-9]\\d{1,14}$', phone_number) is not None"}},{"rule_desc":"Ensure that the file path for downloading public records in 'DownloadPublicRecord' is valid and secure.","rule":"rule @validate_file_path\ntrigger DownloadPublicRecord\ncheck\n    is_valid_file_path\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_valid_file_path":"import os\ndef is_valid_file_path(action_input: Dict, ctx) -> bool:\n    local_file_path = action_input['local_file_path']\n    # Check if the file path is absolute and does not contain dangerous patterns\n    return os.path.isabs(local_file_path) and '..' not in local_file_path"}}]}
{"toolkits":"EpicFHIR","rules":[{"rule_desc":"Ensure user inspection before deleting clinical documents to prevent accidental loss of important data.","rule":"rule @inspect_before_delete_clinical_document\ntrigger ManageClinicalDocuments\naction delete\ncheck\n    is_important_document\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_important_document":"def is_important_document(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the clinical document to be deleted contains important information.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before deleting patient appointments to avoid accidental removal of critical appointments.","rule":"rule @inspect_before_delete_appointment\ntrigger ManageAppointments\naction delete\ncheck\n    is_critical_appointment\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_critical_appointment":"def is_critical_appointment(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the appointment to be deleted is critical or important.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before deleting patient records to prevent accidental loss of vital patient information.","rule":"rule @inspect_before_delete_patient_record\ntrigger ManagePatientRecords\naction delete\ncheck\n    is_vital_patient_record\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_vital_patient_record":"def is_vital_patient_record(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the patient record to be deleted contains vital information.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before deleting diagnostic reports to avoid accidental removal of significant diagnostic data.","rule":"rule @inspect_before_delete_diagnostic_report\ntrigger ManageDiagnosticReports\naction delete\ncheck\n    is_significant_diagnostic_report\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_significant_diagnostic_report":"def is_significant_diagnostic_report(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the diagnostic report to be deleted is significant or contains important results.\", action_input, ctx)"}},{"rule_desc":"Ensure user inspection before downloading files to prevent unauthorized access to sensitive data.","rule":"rule @inspect_before_download_files\ntrigger DownloadFiles\ncheck\n    is_sensitive_file\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_sensitive_file":"def is_sensitive_file(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the files to be downloaded contain sensitive information.\", action_input, ctx)"}}]}
{"toolkits":"TrafficControl","rules":[{"rule_desc":"Ensure safe management of traffic light states to prevent accidents.","rule":"rule @inspect_traffic_light_change\ntrigger ManageTrafficLightState\ncheck\n    is_unsafe_traffic_light_change\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_unsafe_traffic_light_change":"def is_unsafe_traffic_light_change(action_input, ctx):\n    # Check if the traffic light state change is to 'hazard' or if it conflicts with current traffic patterns\n    unsafe_states = ['hazard']\n    return action_input['traffic_light_state'] in unsafe_states"}},{"rule_desc":"Ensure emergency vehicle priority is given only during valid times.","rule":"rule @check_emergency_vehicle_priority\ntrigger GivePriorityToEmergencyVehicle\ncheck\n    is_invalid_priority_time\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_invalid_priority_time":"def is_invalid_priority_time(action_input, ctx):\n    # Check if the priority time is outside of normal emergency response hours\n    from datetime import datetime\n    start_time = datetime.strptime(action_input['start_time'], '%Y-%m-%d %H:%M:%S')\n    end_time = datetime.strptime(action_input['end_time'], '%Y-%m-%d %H:%M:%S')\n    # Assuming normal emergency response hours are between 6 AM and 10 PM\n    return not (6 <= start_time.hour <= 22 and 6 <= end_time.hour <= 22)"}},{"rule_desc":"Ensure road maintenance scheduling does not conflict with peak traffic hours.","rule":"rule @check_road_maintenance_schedule\ntrigger ScheduleRoadMaintenance\ncheck\n    is_during_peak_hours\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_during_peak_hours":"def is_during_peak_hours(action_input, ctx):\n    # Check if the maintenance is scheduled during peak traffic hours\n    from datetime import datetime\n    start_time = datetime.strptime(action_input['start_time'], '%Y-%m-%d %H:%M:%S')\n    end_time = datetime.strptime(action_input['end_time'], '%Y-%m-%d %H:%M:%S')\n    # Assuming peak hours are between 7 AM - 9 AM and 4 PM - 6 PM\n    peak_hours = [(7, 9), (16, 18)]\n    return any(start_time.hour in range(start, end) or end_time.hour in range(start, end) for start, end in peak_hours)"}}]}
{"toolkits":"TDAmeritrade","rules":[{"rule_desc":"Ensure that the user confirms before executing a trade that could result in a significant financial impact.","rule":"rule @confirm_significant_trade\ntrigger TradeStock\ncheck\n    is_significant_trade\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_significant_trade":"def is_significant_trade(action_input: Dict, ctx) -> bool:\n    # Define a threshold for what constitutes a significant trade\n    significant_threshold = 10000  # Example threshold in USD\n    # Calculate the total value of the trade\n    total_value = action_input['quantity'] * action_input.get('price_limit', 0)\n    # If it's a market order, use a placeholder value for price_limit\n    if action_input['order_type'] == 'market_order':\n        # Fetch current stock information to estimate market price\n        stock_info = ctx.get('stock_info', {})\n        estimated_price = stock_info.get('ask', 0) if action_input['action'] == 'buy' else stock_info.get('bid', 0)\n        total_value = action_input['quantity'] * estimated_price\n    return total_value >= significant_threshold"}},{"rule_desc":"Ensure that the user is aware of low account balance before placing a trade.","rule":"rule @check_low_balance\ntrigger TradeStock\ncheck\n    has_low_balance\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_low_balance":"def has_low_balance(action_input: Dict, ctx) -> bool:\n    # Fetch the current balance from the context\n    balance_info = ctx.get('balance', 0)\n    # Define a low balance threshold\n    low_balance_threshold = 500  # Example threshold in USD\n    return balance_info < low_balance_threshold"}}]}
{"toolkits":"InvestmentManager","rules":[{"rule_desc":"Ensure that the transaction amount does not exceed a predefined limit to prevent large unauthorized transactions.","rule":"rule @check_transaction_limit\ntrigger MakeTransaction\ncheck\n    is_transaction_amount_excessive\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_transaction_amount_excessive":"def is_transaction_amount_excessive(action_input: Dict, ctx) -> bool:\n    MAX_TRANSACTION_LIMIT = 10000  # Example limit in USD\n    return action_input['amount'] > MAX_TRANSACTION_LIMIT"}},{"rule_desc":"Verify that the investment option being purchased is suitable for the user's risk profile.","rule":"rule @check_investment_suitability\ntrigger MakeTransaction\ncheck\n    is_investment_suitable\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_investment_suitable":"def is_investment_suitable(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Evaluate if the investment option is suitable for the user's risk profile.\", action_input, ctx)"}},{"rule_desc":"Ensure that the user is aware of the risk disclosures before making a transaction.","rule":"rule @check_risk_disclosure_acknowledgment\ntrigger MakeTransaction\ncheck\n    has_acknowledged_risk_disclosures\nenforce\n    user_inspection\nend","predicate_python_impl":{"has_acknowledged_risk_disclosures":"def has_acknowledged_risk_disclosures(action_input: Dict, ctx) -> bool:\n    return llm_judge(\"Check if the user has acknowledged the risk disclosures for the investment.\", action_input, ctx)"}},{"rule_desc":"Ensure that the transaction history retrieval does not exceed the maximum allowed results.","rule":"rule @check_transaction_history_limit\ntrigger ListTransactions\ncheck\n    is_transaction_history_request_excessive\nenforce\n    user_inspection\nend","predicate_python_impl":{"is_transaction_history_request_excessive":"def is_transaction_history_request_excessive(action_input: Dict, ctx) -> bool:\n    MAX_RESULTS_LIMIT = 50\n    return 'max_results' in action_input and action_input['max_results'] > MAX_RESULTS_LIMIT"}}]}
